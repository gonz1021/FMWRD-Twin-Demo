<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Fox Metro — Digital Twin (Zoomable Basemap)</title>
<meta name="theme-color" content="#0f172a" />
<style>
  :root{
    --bg:#0b1220; --panel:#0f172a; --grid:#1f2937; --muted:#94a3b8;
    --ok:#22c55e; --zoom:1; /* updated by JS */
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  body{ margin:0; background:var(--bg); color:#fff; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  header{ position:sticky; top:0; z-index:50; background:#0f172a; padding:12px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
  header h1{ margin:0; font-size:16px; font-weight:800; }
  button,select{ background:#111827; color:#fff; border:1px solid #334155; border-radius:10px; padding:10px 12px; font-size:14px; }
  button.primary{ background:#2563eb; border-color:#1d4ed8; }
  main{ padding:12px; display:grid; gap:12px; grid-template-columns:1fr; }
  @media (min-width: 980px){ main{ grid-template-columns:1.5fr 1fr; } }
  .card{ background:var(--panel); border:1px solid var(--grid); border-radius:12px; padding:12px; }
  .title{ margin:0 0 8px; font-weight:800; font-size:16px; }
  .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

  /* --- Zoom/Pan canvas --- */
  .mapShell{ position:relative; height:70vh; min-height:360px; border-radius:12px; overflow:hidden; border:1px solid var(--grid); background:#0b1220; }
  .mapViewport{ position:absolute; inset:0; overflow:hidden; touch-action:none; }
  .mapWorld{ position:absolute; left:0; top:0; transform-origin: 0 0; }
  .basemap{ display:block; width:auto; height:auto; max-width:none; user-select:none; pointer-events:none; }
  .marker{
    position:absolute; left:0; top:0;
    width:32px; height:32px; border-radius:50%; border:2px solid #fff;
    background:var(--ok); color:#000; font-weight:800; display:flex; align-items:center; justify-content:center;
    transform: translate(-50%,-50%) scale(calc(1/var(--zoom)));
    cursor:grab; user-select:none;
  }
  .marker.dragging{ opacity:.8; cursor:grabbing; }
  .hint{ color:var(--muted); font-size:12px; }

  canvas{ width:100%; height:220px; border:1px solid var(--grid); border-radius:8px; background:#0b1220; }
</style>
</head>
<body>
<header>
  <h1>Fox Metro — Digital Twin</h1>
  <div class="toolbar">
    <button id="btnEdit" class="primary">Enter Map Edit</button>
    <button id="btnDone" style="display:none">Done</button>
    <button id="btnExport">⬇ Export Layout</button>
    <label class="hint">Import <input id="fileImport" type="file" accept=".json"></label>
    <select id="speed">
      <option value="400">Speed 1×</option>
      <option value="250">1.5×</option>
      <option value="150">2×</option>
      <option value="80">4×</option>
    </select>
  </div>
</header>

<main>
  <section class="card">
    <h3 class="title">Basemap (Zoom + Pan + Click-to-Place)</h3>
    <div class="mapShell">
      <div id="viewport" class="mapViewport">
        <div id="world" class="mapWorld">
          <img id="img" class="basemap" src="./basemap.png" alt="Basemap" />
          <!-- markers injected here -->
        </div>
      </div>
    </div>
    <p class="hint" id="editHint">Tap “Enter Map Edit” to enable: pinch/scroll to zoom, drag to pan, tap to add markers, drag markers to refine. Markers auto-resize while you zoom.</p>
  </section>

  <section class="card">
    <h3 class="title">Telemetry & Charts</h3>
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
      <canvas id="rain"></canvas>
      <canvas id="wet"></canvas>
    </div>
    <p class="hint" id="telemetry">Select a marker.</p>
  </section>
</main>

<script>
/* =========================================================
   CONFIG: basemap source (change if you prefer a RAW URL)
   ========================================================= */
const BASEMAP_URL = "https://raw.githubusercontent.com/gonz1021/FMWRD-Twin-Demo/refs/heads/main/IMG_8532.jpeg";  // put basemap.png next to index.html

/* =========================================================
   ZOOM + PAN + MARKERS (no libs)
   ========================================================= */
const img = document.getElementById('img');
const viewport = document.getElementById('viewport');
const world = document.getElementById('world');
const btnEdit = document.getElementById('btnEdit');
const btnDone = document.getElementById('btnDone');
const speedSel = document.getElementById('speed');

let editMode = false;
let scale = 1;          // zoom factor
let ox = 0, oy = 0;     // world origin translation (px)
let draggingView = false, dragStartX = 0, dragStartY = 0, startOX=0, startOY=0;

let imgW = 0, imgH = 0;
const markers = []; // {id, xpct, ypct, el}

document.documentElement.style.setProperty('--zoom', scale);

/* ---- load image then size world ---- */
img.onload = () => {
  imgW = img.naturalWidth;
  imgH = img.naturalHeight;
  sizeToFit();
  renderWorld();
};
img.onerror = () => alert("Basemap not found. Ensure basemap.png is in the repo root.");
img.src = BASEMAP_URL;

/* ---- helpers ---- */
function sizeToFit(){
  const r = viewport.getBoundingClientRect();
  const sx = r.width / imgW;
  const sy = r.height / imgH;
  scale = Math.min(sx, sy);       // fit to view
  ox = Math.max(0, (r.width - imgW*scale)/2);
  oy = Math.max(0, (r.height - imgH*scale)/2);
  updateZoomVar();
}
function updateZoomVar(){ document.documentElement.style.setProperty('--zoom', scale); }
function renderWorld(){
  world.style.transform = `translate(${ox}px, ${oy}px) scale(${scale})`;
}

/* ---- zoom (wheel & pinch) ---- */
viewport.addEventListener('wheel', (e)=>{
  if(!editMode) return;
  e.preventDefault();
  const rect = viewport.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  zoomAbout(mx, my, e.deltaY<0 ? 1.1 : 1/1.1);
});
let pinch=false, startD=0, startScale=1, pinchCenter={x:0,y:0};
viewport.addEventListener('touchstart', (e)=>{
  if(!editMode) return;
  if(e.touches.length===2){
    pinch=true;
    startD = dist(e.touches[0], e.touches[1]);
    startScale = scale;
    const rect = viewport.getBoundingClientRect();
    pinchCenter = {
      x:(e.touches[0].clientX+e.touches[1].clientX)/2 - rect.left,
      y:(e.touches[0].clientY+e.touches[1].clientY)/2 - rect.top
    };
  } else if(e.touches.length===1){
    beginDrag(e.touches[0].clientX, e.touches[0].clientY);
  }
},{passive:false});
viewport.addEventListener('touchmove', (e)=>{
  if(!editMode) return;
  if(pinch && e.touches.length===2){
    e.preventDefault();
    const d = dist(e.touches[0], e.touches[1]);
    const f = d/startD;
    scale = clamp(startScale*f, 0.2, 6);
    zoomAbout(pinchCenter.x, pinchCenter.y, 1, true); // recalc translation only
  } else if(draggingView && e.touches.length===1){
    drag(e.touches[0].clientX, e.touches[0].clientY);
  }
},{passive:false});
viewport.addEventListener('touchend', ()=>{ pinch=false; endDrag(); });

function dist(a,b){ return Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

function zoomAbout(mx, my, factor, absolute=false){
  const wx = (mx - ox) / scale; // world coords
  const wy = (my - oy) / scale;
  if(!absolute){ scale = clamp(scale*factor, 0.2, 6); }
  ox = mx - wx*scale;
  oy = my - wy*scale;
  updateZoomVar();
  renderWorld();
}

/* ---- pan ---- */
viewport.addEventListener('mousedown', (e)=>{ if(!editMode) return; beginDrag(e.clientX, e.clientY); });
window.addEventListener('mousemove', (e)=>{ if(!editMode) return; drag(e.clientX, e.clientY); });
window.addEventListener('mouseup', endDrag);
function beginDrag(x,y){ draggingView=true; dragStartX=x; dragStartY=y; startOX=ox; startOY=oy; }
function drag(x,y){ if(!draggingView) return; ox = startOX + (x-dragStartX); oy = startOY + (y-dragStartY); renderWorld(); }
function endDrag(){ draggingView=false; }

/* ---- click to add marker (edit mode) ---- */
viewport.addEventListener('click', (e)=>{
  if(!editMode) return;
  // ignore if click ended on an existing marker drag
  if(e.target.classList.contains('marker')) return;

  const rect = viewport.getBoundingClientRect();
  const vx = e.clientX - rect.left;
  const vy = e.clientY - rect.top;
  const wx = (vx - ox) / scale;      // world (image px)
  const wy = (vy - oy) / scale;

  const xpct = wx / imgW;
  const ypct = wy / imgH;
  const id = "P" + (markers.length+1);
  addMarker({id, xpct, ypct});
});

/* ---- markers ---- */
function addMarker({id, xpct, ypct}){
  const el = document.createElement('div');
  el.className='marker';
  el.textContent = id.replace('P','');
  world.appendChild(el);
  const m = {id, xpct, ypct, el}; markers.push(m);
  positionMarker(m);
  // drag marker
  let dragM=false, sx=0, sy=0, startXP=0, startYP=0;
  el.addEventListener('mousedown', (e)=>{ if(!editMode) return; e.stopPropagation(); dragM=true; el.classList.add('dragging'); sx=e.clientX; sy=e.clientY; startXP=m.xpct; startYP=m.ypct; });
  window.addEventListener('mousemove', (e)=>{ if(!dragM) return; const dx=(e.clientX-sx)/scale, dy=(e.clientY-sy)/scale; m.xpct = clamp(startXP + dx/imgW, 0, 1); m.ypct = clamp(startYP + dy/imgH, 0, 1); positionMarker(m); });
  window.addEventListener('mouseup', ()=>{ if(dragM){ dragM=false; el.classList.remove('dragging'); }});
  // touch
  el.addEventListener('touchstart', (e)=>{ if(!editMode) return; e.stopPropagation(); const t=e.changedTouches[0]; dragM=true; el.classList.add('dragging'); sx=t.clientX; sy=t.clientY; startXP=m.xpct; startYP=m.ypct; }, {passive:false});
  window.addEventListener('touchmove', (e)=>{ if(!dragM) return; const t=e.changedTouches?.[0]; if(!t) return; const dx=(t.clientX-sx)/scale, dy=(t.clientY-sy)/scale; m.xpct = clamp(startXP + dx/imgW, 0, 1); m.ypct = clamp(startYP + dy/imgH, 0, 1); positionMarker(m); }, {passive:false});
  window.addEventListener('touchend', ()=>{ if(dragM){ dragM=false; el.classList.remove('dragging'); }});
}
function positionMarker(m){
  const x = m.xpct * imgW;
  const y = m.ypct * imgH;
  m.el.style.left = x + 'px';
  m.el.style.top  = y + 'px';
}

/* ---- edit/done ---- */
btnEdit.addEventListener('click', ()=>{
  editMode = true;
  btnEdit.style.display='none';
  btnDone.style.display='inline-block';
  document.getElementById('editHint').textContent = "Edit mode ON — click to add, drag markers, pinch/scroll to zoom, drag to pan. Tap Done when finished.";
});
btnDone.addEventListener('click', ()=>{
  editMode = false;
  btnEdit.style.display='inline-block';
  btnDone.style.display='none';
  document.getElementById('editHint').textContent = "Edit mode OFF — use controls & charts.";
});

/* ---- export/import (% coords) ---- */
document.getElementById('btnExport').addEventListener('click', ()=>{
  const payload = markers.map(m=>({id:m.id, xpct:m.xpct, ypct:m.ypct}));
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='station_layout.json'; a.click();
  URL.revokeObjectURL(url);
});
document.getElementById('fileImport').addEventListener('change', (e)=>{
  const f=e.target.files[0]; if(!f) return; const r=new FileReader();
  r.onload = ev => {
    try{
      const arr = JSON.parse(ev.target.result);
      // remove existing
      markers.splice(0, markers.length);
      Array.from(world.querySelectorAll('.marker')).forEach(n=>n.remove());
      (arr||[]).forEach(o=> addMarker({id:o.id||("P?"), xpct:o.xpct, ypct:o.ypct}));
    }catch{ alert('Invalid JSON'); }
  };
  r.readAsText(f);
});

/* =========================================================
   (Optional) quick mock charts — just to keep the page intact
   ========================================================= */
const rain = document.getElementById('rain');
const wet  = document.getElementById('wet');
[rain,wet].forEach(c=>{
  const r=c.getBoundingClientRect(), d=window.devicePixelRatio||1;
  c.width=Math.floor(r.width*d); c.height=220*d;
  const x=c.getContext('2d'); x.strokeStyle='#334155'; x.strokeRect(10,10,c.width-20,c.height-20);
  x.fillStyle='#94a3b8'; x.fillText('Charts placeholder', 20*d, 30*d);
});
window.addEventListener('resize', ()=>[rain,wet].forEach(c=>{
  const r=c.getBoundingClientRect(), d=window.devicePixelRatio||1;
  c.width=Math.floor(r.width*d); c.height=220*d;
}));

</script>
</body>
</html>
